1.MySQL
MySQL常见的存储引擎InnoDB、MyISAM的区别？
1）事务：MyISAM不支持，InnoDB支持
2）锁级别： MyISAM 表级锁，InnoDB 行级锁
适用场景：
MyISAM适合： 插入不频繁，查询非常频繁，如果执行大量的SELECT，MyISAM是更好的选择， 没有事务。
InnoDB适合： 可靠性要求比较高，或者要求事务； 表更新和查询都相当的频繁， 大量的INSERT或UPDATE

内连接、外连接（左、右、全）、交叉连接的区别
内连接：只有两个元素表相匹配的才能在结果集中显示。
外连接： 左外连接: 左边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。
右外连接:右边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。
全外连接：连接的表中不匹配的数据全部会显示出来。
交叉连接： 笛卡尔效应，显示的结果是链接表数的乘积。


MySQL 索引优化
建索引，防止全表扫描
MySQL 索引通常是被用于提高 WHERE 条件的数据行匹配时的搜索速度

mysql库主从读写分离。
开启 binary log ,主服务器把操作记录到binary log——>从服务器将binary log中的数据同步到relay log（中继日志）——>从服务器读取中继日志执行同步数据

将读操作和写操作分离到不同的数据库上，避免主服务器出现性能瓶颈；主服务器进行写操作时，不影响查询应用服务器的查询性能，降低阻塞，提高并发； 
数据拥有多个容灾副本，提高数据安全性，同时当主服务器故障时，可立即切换到其他服务器，提高系统可用性；


2.Redis

Redis与memcached相比　有哪些优势?
Redis 支持５种数据类型：　String , List , Set , SortSet ,Hash
Redis 支持数据持久化: RDD 和ＡOF　当内存数据达到一定阀值，flush到硬盘．

RDB是Redis默认的持久化方式。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即Snapshot快照存储，对应产生的数据文件为dump.rdb，通过配置文件中的save参数来定义快照的周期。（ 快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。）
AOF：Redis会将每一个收到的写命令都通过Write函数追加到文件最后，类似于MySQL的binlog。当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。
当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。

缓存雪崩我们可以简单的理解为：由于原有缓存失效，新缓存未到期间
(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，
而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。
解决办法：
大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，
从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开。

缓存穿透
缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，
每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。
解决办法;
最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，
从而避免了对底层存储系统的查询压力。

主从复制，读写分离
主库开启AOF，从库指定master IP
一类是主数据库（master）一类是从数据库（slave），主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，
而从数据库一般是只读的，并接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。

Redis 常见性能问题和解决方案？
(1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件
(2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次
(3) 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内


3.Shell

求和

#!/bin/bash

s=0
for((i=0;i<=100;i++))
do
        s=$[$s+$i]
done
echo $s

$a = 1+2
print $a

expr 1 + 2


1.找出file.txt中空行所在的行号
grep -n "^$" file1
awk '/^$/{print NR}' file.txt

2.把file.txt中的enforcing改成disabled

sed -i 's/enforcing/disabled/g' file.txt



4.Shell脚本里如何检查一个文件是否存在？如果不存在该如何处理？

 #!/bin/bash

if [ -f file.txt ]
then
   echo "文件存在!"
else
   echo "文件不存在!"
fi

5.用shell写一个脚本，对文本中无序的一列数字排序并求和

排序:
sort -n file.txt

排序&求和:

sort -n file.txt|awk '{sum = sum+$1} END {print sum}'

awk -F ' ' '{sum=sum+$2} END {print sum}'  file.txt

1）计算两个输入参数的和
[atguigu@hadoop101 datas]$ touch fun.sh
[atguigu@hadoop101 datas]$ vim fun.sh

#!/bin/bash
function sum()
{
    s=0
    s=$[ $1 + $2 ]
    echo "$s"
}

read -p "Please input the number1: " n1;
read -p "Please input the number2: " n2;
sum $n1 $n2;

过滤出ip 地址：
ip add|grep '88/'|awk -F ' ' '{ print $2}'|awk -F '/' '{print $1}'


处理一下文件内容，将域名取出并根据域名进行计数排序处理（百度和sohu面试题）

http://www.etiantian.org/index.html
http://www.etiantian.org/1.html
http://post.etiantian.org/index.html 
http://mp3.etiantian.org/index.html
http://www.etiantian.org/3.html
http://post.etiantian.org/2.html

cat access.log |awk -F '/' '{print $3}'|sort|uniq -c


4.Python
列表去重
list1 = [2, 3, 8, 4, 9, 5, 6, 5, 6, 10, 17, 11, 2]

list = set(list1)

升序排序　
sorted(list)

降序排序
sorted(list,reverse=True)

闭包
闭包就是引用了自有变量的函数，这个函数保存了执行的上下文，可以脱离原本的作用域独立存在。
https://www.jianshu.com/p/ee82b941772a

什么是装饰器
装饰器是要把原来的函数装饰成新的函数，并且返回这个函数本身的高阶函数
装饰器这一语法体现了Python中函数是第一要素，函数是对象、是变量，可以作为参数、可以是返回值。


copy深拷贝　带属性拷贝
copy.deepcopy

内存管理
Python引用了一个内存池(memory pool)机制，即Pymalloc机制(malloc:n.分配内存)，用于管理对小块内存的申请和释放
内存池（memory pool）的概念：
　　当 创建大量消耗小内存的对象时，频繁调用new/malloc会导致大量的内存碎片，致使效率降低。内存池的概念就是预先在内存中申请一定数量的，
  大小相等 的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，
  提升效率。



